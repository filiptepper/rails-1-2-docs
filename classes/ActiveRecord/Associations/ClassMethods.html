<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>ActiveRecord::Associations::ClassMethods</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../css/github.css" type="text/css" media="screen" />
<script src="../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            <span class="type">Module</span> 
            ActiveRecord::Associations::ClassMethods 
            
        </h1>
        <ul class="files">
            
            <li><a href="../../../files/rails/activerecord/lib/active_record/associations_rb.html">rails/activerecord/lib/active_record/associations.rb</a></li>
            
            <li><a href="../../../files/rails/activerecord/lib/active_record/deprecated_associations_rb.html">rails/activerecord/lib/active_record/deprecated_associations.rb</a></li>
            
        </ul>
    </div>
    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p><a href="../Associations.html">Associations</a> are a set of macro-like
class methods for tying objects together through foreign keys. They express
relationships like  "<a href="../../Project.html">Project</a> has one <a
href="../../Project.html">Project</a> Manager" or "<a
href="../../Project.html">Project</a> belongs to a Portfolio". Each macro
adds a number of methods to the class which are  specialized according to
the collection or association symbol and the options hash. It works much
the same way as Ruby's own attr*  methods. Example:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Project</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">belongs_to</span>              :<span class="ruby-identifier">portfolio</span>
  <span class="ruby-identifier">has_one</span>                 :<span class="ruby-identifier">project_manager</span> 
  <span class="ruby-identifier">has_many</span>                :<span class="ruby-identifier">milestones</span>
  <span class="ruby-identifier">has_and_belongs_to_many</span> :<span class="ruby-identifier">categories</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The project class now has the following methods (and more) to ease the
traversal and manipulation of its relationships:</p>
<ul><li>
<p><code>Project#portfolio, Project#portfolio=(portfolio),
Project#portfolio.nil?</code></p>
</li><li>
<p><code>Project#project_manager, Project#project_manager=(project_manager),
Project#project_manager.nil?,</code></p>
</li><li>
<p><code>Project#milestones.empty?, Project#milestones.size,
Project#milestones, Project#milestones&lt;&lt;(milestone),</code>
<code>Project#milestones.delete(milestone),
Project#milestones.find(milestone_id), Project#milestones.find(:all,
options),</code> <code>Project#milestones.build,
Project#milestones.create</code></p>
</li><li>
<p><code>Project#categories.empty?, Project#categories.size,
Project#categories, Project#categories&lt;&lt;(category1),</code>
<code>Project#categories.delete(category1)</code></p>
</li></ul>

<h2 id="label-Example">Example</h2>

<p><img src="../../../files/examples/associations.png" /></p>

<h2 id="label-Is+it+belongs_to+or+has_one%3F">Is it <a href="ClassMethods.html#method-i-belongs_to">#belongs_to</a> or <a href="ClassMethods.html#method-i-has_one">#has_one</a>?</h2>

<p>Both express a 1-1 relationship, the difference is mostly where to place
the foreign key, which goes on the table for the class saying belongs_to.
Example:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">User</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-comment"># I reference an account.</span>
  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">account</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Account</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-comment"># One user references me.</span>
  <span class="ruby-identifier">has_one</span> :<span class="ruby-identifier">user</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The tables for these classes could look something like:</p>

<pre>CREATE TABLE users (
  id int(11) NOT NULL auto_increment,
  account_id int(11) default NULL,
  name varchar default NULL,
  PRIMARY KEY  (id)
)

CREATE TABLE accounts (
  id int(11) NOT NULL auto_increment,
  name varchar default NULL,
  PRIMARY KEY  (id)
)</pre>

<h2 id="label-Unsaved+objects+and+associations">Unsaved objects and associations</h2>

<p>You can manipulate objects and associations before they are saved to the
database, but there is some special behaviour you should be aware of,
mostly involving the saving of associated objects.</p>

<h3 id="label-One-to-one+associations">One-to-one associations</h3>
<ul><li>
<p>Assigning an object to a <a
href="ClassMethods.html#method-i-has_one">#has_one</a> association
automatically saves that object and the object being replaced (if there is
one), in order to update their primary keys - except if the parent object
is unsaved (new_record? == true).</p>
</li><li>
<p>If either of these saves fail (due to one of the objects being invalid) the
assignment statement returns false and the assignment is cancelled.</p>
</li><li>
<p>If you wish to assign an object to a <a
href="ClassMethods.html#method-i-has_one">#has_one</a> association without
saving it, use the association.build method (documented below).</p>
</li><li>
<p>Assigning an object to a <a
href="ClassMethods.html#method-i-belongs_to">#belongs_to</a> association
does not save the object, since the foreign key field belongs on the
parent. It does not save the parent either.</p>
</li></ul>

<h3 id="label-Collections">Collections</h3>
<ul><li>
<p>Adding an object to a collection (<a
href="ClassMethods.html#method-i-has_many">#has_many</a> or <a
href="ClassMethods.html#method-i-has_and_belongs_to_many">#has_and_belongs_to_many</a>)
automatically saves that object, except if the parent object (the owner of
the collection) is not yet stored in the database.</p>
</li><li>
<p>If saving any of the objects being added to a collection (via push or
similar) fails, then push returns false.</p>
</li><li>
<p>You can add an object to a collection without automatically saving it by
using the collection.build method (documented below).</p>
</li><li>
<p>All unsaved (new_record? == true) members of the collection are
automatically saved when the parent is saved.</p>
</li></ul>

<h3 id="label-Association+callbacks">Association callbacks</h3>

<p>Similiar to the normal callbacks that hook into the lifecycle of an Active
Record object, you can also define callbacks that get trigged when you add
an object to or removing an object from a association collection. Example:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Project</span>
  <span class="ruby-identifier">has_and_belongs_to_many</span> :<span class="ruby-identifier">developers</span>, :<span class="ruby-identifier">after_add</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">evaluate_velocity</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">evaluate_velocity</span>(<span class="ruby-identifier">developer</span>)
    <span class="ruby-operator">...</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>It’s possible to stack callbacks by passing them as an array. Example:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Project</span>
  <span class="ruby-identifier">has_and_belongs_to_many</span> :<span class="ruby-identifier">developers</span>, :<span class="ruby-identifier">after_add</span> =<span class="ruby-operator">&gt;</span> [:<span class="ruby-identifier">evaluate_velocity</span>, <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">p</span>, <span class="ruby-identifier">d</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">shipping_date</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>}]
<span class="ruby-keyword">end</span>
</pre>

<p>Possible callbacks are: before_add, after_add, before_remove and
after_remove.</p>

<p>Should any of the before_add callbacks throw an exception, the object does
not get added to the collection. Same with the before_remove callbacks, if
an exception is thrown the object doesn’t get removed.</p>

<h3 id="label-Association+extensions">Association extensions</h3>

<p>The proxy objects that controls the access to associations can be extended
through anonymous modules. This is especially beneficial for adding new
finders, creators, and other factory-type methods that are only used as
part of this association. Example:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Account</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">people</span> <span class="ruby-keyword">do</span>
    <span class="ruby-keyword">def</span> <span class="ruby-identifier">find_or_create_by_name</span>(<span class="ruby-identifier">name</span>)
      <span class="ruby-identifier">first_name</span>, <span class="ruby-identifier">last_name</span> = <span class="ruby-identifier">name</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&quot; &quot;</span>, <span class="ruby-value">2</span>)
      <span class="ruby-identifier">find_or_create_by_first_name_and_last_name</span>(<span class="ruby-identifier">first_name</span>, <span class="ruby-identifier">last_name</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">person</span> = <span class="ruby-constant">Account</span>.<span class="ruby-identifier">find</span>(:<span class="ruby-identifier">first</span>).<span class="ruby-identifier">people</span>.<span class="ruby-identifier">find_or_create_by_name</span>(<span class="ruby-string">&quot;David Heinemeier Hansson&quot;</span>)
<span class="ruby-identifier">person</span>.<span class="ruby-identifier">first_name</span> <span class="ruby-comment"># =&gt; &quot;David&quot;</span>
<span class="ruby-identifier">person</span>.<span class="ruby-identifier">last_name</span>  <span class="ruby-comment"># =&gt; &quot;Heinemeier Hansson&quot;</span>
</pre>

<p>If you need to share the same extensions between many associations, you can
use a named extension module. Example:</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">FindOrCreateByNameExtension</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">find_or_create_by_name</span>(<span class="ruby-identifier">name</span>)
    <span class="ruby-identifier">first_name</span>, <span class="ruby-identifier">last_name</span> = <span class="ruby-identifier">name</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&quot; &quot;</span>, <span class="ruby-value">2</span>)
    <span class="ruby-identifier">find_or_create_by_first_name_and_last_name</span>(<span class="ruby-identifier">first_name</span>, <span class="ruby-identifier">last_name</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Account</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">people</span>, :<span class="ruby-identifier">extend</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">FindOrCreateByNameExtension</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Company</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">people</span>, :<span class="ruby-identifier">extend</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">FindOrCreateByNameExtension</span>
<span class="ruby-keyword">end</span>
</pre>

<p>If you need to use multiple named extension modules, you can specify an
array of modules with the :extend option. In the case of name conflicts
between methods in the modules, methods in modules later in the array
supercede those earlier in the array. Example:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Account</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">people</span>, :<span class="ruby-identifier">extend</span> =<span class="ruby-operator">&gt;</span> [<span class="ruby-constant">FindOrCreateByNameExtension</span>, <span class="ruby-constant">FindRecentExtension</span>]
<span class="ruby-keyword">end</span>
</pre>

<p>Some extensions can only be made to work with knowledge of the association
proxy’s internals. Extensions can access relevant state using accessors on
the association proxy:</p>
<ul><li>
<p><code>proxy_owner</code> - Returns the object the association is part of.</p>
</li><li>
<p><code>proxy_reflection</code> - Returns the reflection object that
describes the association.</p>
</li><li>
<p><code>proxy_target</code> - Returns the associated object for <a
href="ClassMethods.html#method-i-belongs_to">#belongs_to</a> and <a
href="ClassMethods.html#method-i-has_one">#has_one</a>, or the collection
of associated objects for <a
href="ClassMethods.html#method-i-has_many">#has_many</a> and
has_and_belongs_to_many.</p>
</li></ul>

<h3 id="label-Association+Join+Models">Association Join Models</h3>

<p>Has Many associations can be configured with the :through option to use an
explicit join model to retrieve the data.  This operates similarly to a
<code>has_and_belongs_to_many</code> association.  The advantage is that
you’re able to add validations, callbacks, and extra attributes on the join
model.  Consider the following schema:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Author</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">authorships</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">books</span>, :<span class="ruby-identifier">through</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">authorships</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Authorship</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">author</span>
  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">book</span>
<span class="ruby-keyword">end</span>

<span class="ruby-ivar">@author</span> = <span class="ruby-constant">Author</span>.<span class="ruby-identifier">find</span> :<span class="ruby-identifier">first</span>
<span class="ruby-ivar">@author</span>.<span class="ruby-identifier">authorships</span>.<span class="ruby-identifier">collect</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">book</span> } <span class="ruby-comment"># selects all books that the author's authorships belong to.</span>
<span class="ruby-ivar">@author</span>.<span class="ruby-identifier">books</span>                              <span class="ruby-comment"># selects all books by using the Authorship join model</span>
</pre>

<p>You can also go through a <a
href="ClassMethods.html#method-i-has_many">#has_many</a> association on the
join model:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Firm</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">has_many</span>   :<span class="ruby-identifier">clients</span>
  <span class="ruby-identifier">has_many</span>   :<span class="ruby-identifier">invoices</span>, :<span class="ruby-identifier">through</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">clients</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Client</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">firm</span>
  <span class="ruby-identifier">has_many</span>   :<span class="ruby-identifier">invoices</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Invoice</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">client</span>
<span class="ruby-keyword">end</span>

<span class="ruby-ivar">@firm</span> = <span class="ruby-constant">Firm</span>.<span class="ruby-identifier">find</span> :<span class="ruby-identifier">first</span>
<span class="ruby-ivar">@firm</span>.<span class="ruby-identifier">clients</span>.<span class="ruby-identifier">collect</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">invoices</span> }.<span class="ruby-identifier">flatten</span> <span class="ruby-comment"># select all invoices for all clients of the firm</span>
<span class="ruby-ivar">@firm</span>.<span class="ruby-identifier">invoices</span>                                   <span class="ruby-comment"># selects all invoices by going through the Client join model.</span>
</pre>

<h3 id="label-Polymorphic+Associations">Polymorphic <a href="../Associations.html">Associations</a></h3>

<p>Polymorphic associations on models are not restricted on what types of
models they can be associated with.  Rather, they  specify an interface
that a <a href="ClassMethods.html#method-i-has_many">#has_many</a>
association must adhere to.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Asset</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">attachable</span>, :<span class="ruby-identifier">polymorphic</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Post</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">assets</span>, :<span class="ruby-identifier">as</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">attachable</span>         <span class="ruby-comment"># The &lt;tt&gt;:as&lt;/tt&gt; option specifies the polymorphic interface to use.</span>
<span class="ruby-keyword">end</span>

<span class="ruby-ivar">@asset</span>.<span class="ruby-identifier">attachable</span> = <span class="ruby-ivar">@post</span>
</pre>

<p>This works by using a type column in addition to a foreign key to specify
the associated record.  In the Asset example, you’d need an attachable_id
integer column and an attachable_type string column.</p>

<p>Using polymorphic associations in combination with single table inheritance
(STI) is a little tricky. In order for the associations to work as
expected, ensure that you store the base model for the STI models in the 
type column of the polymorphic association. To continue with the asset
example above, suppose there are guest posts and member posts that use the
posts table for STI. So there will be an additional ‘type’ column in the
posts table.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Asset</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">attachable</span>, :<span class="ruby-identifier">polymorphic</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">attachable_type=</span>(<span class="ruby-identifier">sType</span>)
     <span class="ruby-keyword">super</span>(<span class="ruby-identifier">sType</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">classify</span>.<span class="ruby-identifier">constantize</span>.<span class="ruby-identifier">base_class</span>.<span class="ruby-identifier">to_s</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Post</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-comment"># because we store &quot;Post&quot; in attachable_type now :dependent =&gt; :destroy will work</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">assets</span>, :<span class="ruby-identifier">as</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">attachable</span>, :<span class="ruby-identifier">dependent</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">destroy</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">GuestPost</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">MemberPost</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-Caching">Caching</h2>

<p>All of the methods are built on a simple caching principle that will keep
the result of the last query around unless specifically instructed not to.
The cache is even shared across methods to make it even cheaper to use the
macro-added methods without  worrying too much about performance at the
first go. Example:</p>

<pre>project.milestones             # fetches milestones from the database
project.milestones.size        # uses the milestone cache
project.milestones.empty?      # uses the milestone cache
project.milestones(true).size  # fetches milestones from the database
project.milestones             # uses the milestone cache</pre>

<h2 id="label-Eager+loading+of+associations">Eager loading of associations</h2>

<p>Eager loading is a way to find objects of a certain class and a number of
named associations along with it in a single SQL call. This is one of the
easiest ways of to prevent the dreaded 1+N problem in which fetching 100
posts that each needs to display their author triggers 101 database
queries. Through the use of eager loading, the 101 queries can be reduced
to 1. Example:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Post</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">author</span>
  <span class="ruby-identifier">has_many</span>   :<span class="ruby-identifier">comments</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Consider the following loop using the class above:</p>

<pre>for post in Post.find(:all)
  puts &quot;Post:            &quot; + post.title
  puts &quot;Written by:      &quot; + post.author.name
  puts &quot;Last comment on: &quot; + post.comments.first.created_on
end</pre>

<p>To iterate over these one hundred posts, we’ll generate 201 database
queries. Let’s first just optimize it for retrieving the author:</p>

<pre class="ruby"><span class="ruby-keyword">for</span> <span class="ruby-identifier">post</span> <span class="ruby-keyword">in</span> <span class="ruby-constant">Post</span>.<span class="ruby-identifier">find</span>(:<span class="ruby-identifier">all</span>, :<span class="ruby-identifier">include</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">author</span>)
</pre>

<p>This references the name of the <a
href="ClassMethods.html#method-i-belongs_to">#belongs_to</a> association
that also used the :author symbol, so the find will now weave in a join
something like this: LEFT OUTER JOIN authors ON authors.id =
posts.author_id. Doing so will cut down the number of queries from 201 to
101.</p>

<p>We can improve upon the situation further by referencing both associations
in the finder with:</p>

<pre class="ruby"><span class="ruby-keyword">for</span> <span class="ruby-identifier">post</span> <span class="ruby-keyword">in</span> <span class="ruby-constant">Post</span>.<span class="ruby-identifier">find</span>(:<span class="ruby-identifier">all</span>, :<span class="ruby-identifier">include</span> =<span class="ruby-operator">&gt;</span> [ :<span class="ruby-identifier">author</span>, :<span class="ruby-identifier">comments</span> ])
</pre>

<p>That’ll add another join along the lines of: LEFT OUTER JOIN comments ON
comments.post_id = posts.id. And we’ll be down to 1 query.</p>

<p>To include a deep hierarchy of associations, using a hash:</p>

<pre class="ruby"><span class="ruby-keyword">for</span> <span class="ruby-identifier">post</span> <span class="ruby-keyword">in</span> <span class="ruby-constant">Post</span>.<span class="ruby-identifier">find</span>(:<span class="ruby-identifier">all</span>, :<span class="ruby-identifier">include</span> =<span class="ruby-operator">&gt;</span> [ :<span class="ruby-identifier">author</span>, { :<span class="ruby-identifier">comments</span> =<span class="ruby-operator">&gt;</span> { :<span class="ruby-identifier">author</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">gravatar</span> } } ])
</pre>

<p>That’ll grab not only all the comments but all their authors and gravatar
pictures.  You can mix and match symbols, arrays and hashes in any
combination to describe the associations you want to load.</p>

<p>All of this power shouldn’t fool you into thinking that you can pull out
huge amounts of data with no performance penalty just because you’ve
reduced the number of queries. The database still needs to send all the
data to Active Record and it still needs to be processed. So it’s no
catch-all for performance problems, but it’s a great way to cut down on the
number of queries in a situation as the one described above.</p>

<p>Since the eager loading pulls from multiple tables, you’ll have to
disambiguate any column references in both conditions and orders. So :order
=&gt; “posts.id DESC” will work while :order =&gt; “id DESC” will not.
Because eager loading generates the SELECT statement too, the :select
option is ignored.</p>

<p>You can use eager loading on multiple associations from the same table, but
you cannot use those associations in orders and conditions as there is
currently not any way to disambiguate them. Eager loading will not pull
additional attributes on join tables, so “rich associations” with <a
href="ClassMethods.html#method-i-has_and_belongs_to_many">#has_and_belongs_to_many</a>
are not a good fit for eager loading.</p>

<p>When eager loaded, conditions are interpolated in the context of the model
class, not the model instance.  Conditions are lazily interpolated before
the actual model exists.</p>

<h2 id="label-Table+Aliasing">Table Aliasing</h2>

<p><a href="../../ActiveRecord.html">ActiveRecord</a> uses table aliasing in
the case that a table is referenced multiple times in a join.  If a table
is referenced only once, the standard table name is used.  The second time,
the table is aliased as #{reflection_name}_#{parent_table_name}.  Indexes
are appended for any more successive uses of the table name.</p>

<pre class="ruby"><span class="ruby-constant">Post</span>.<span class="ruby-identifier">find</span> :<span class="ruby-identifier">all</span>, :<span class="ruby-identifier">include</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">comments</span>
<span class="ruby-comment"># =&gt; SELECT ... FROM posts LEFT OUTER JOIN comments ON ...</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">find</span> :<span class="ruby-identifier">all</span>, :<span class="ruby-identifier">include</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">special_comments</span> <span class="ruby-comment"># STI</span>
<span class="ruby-comment"># =&gt; SELECT ... FROM posts LEFT OUTER JOIN comments ON ... AND comments.type = 'SpecialComment'</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">find</span> :<span class="ruby-identifier">all</span>, :<span class="ruby-identifier">include</span> =<span class="ruby-operator">&gt;</span> [:<span class="ruby-identifier">comments</span>, :<span class="ruby-identifier">special_comments</span>] <span class="ruby-comment"># special_comments is the reflection name, posts is the parent table name</span>
<span class="ruby-comment"># =&gt; SELECT ... FROM posts LEFT OUTER JOIN comments ON ... LEFT OUTER JOIN comments special_comments_posts</span>
</pre>

<p><a href="../Acts.html">Acts</a> as tree example:</p>

<pre class="ruby"><span class="ruby-constant">TreeMixin</span>.<span class="ruby-identifier">find</span> :<span class="ruby-identifier">all</span>, :<span class="ruby-identifier">include</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">children</span>
<span class="ruby-comment"># =&gt; SELECT ... FROM mixins LEFT OUTER JOIN mixins childrens_mixins ...</span>
<span class="ruby-constant">TreeMixin</span>.<span class="ruby-identifier">find</span> :<span class="ruby-identifier">all</span>, :<span class="ruby-identifier">include</span> =<span class="ruby-operator">&gt;</span> {:<span class="ruby-identifier">children</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">parent</span>} <span class="ruby-comment"># using cascading eager includes</span>
<span class="ruby-comment"># =&gt; SELECT ... FROM mixins LEFT OUTER JOIN mixins childrens_mixins ... </span>
                            <span class="ruby-constant">LEFT</span> <span class="ruby-constant">OUTER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">parents_mixins</span> <span class="ruby-operator">...</span>
<span class="ruby-constant">TreeMixin</span>.<span class="ruby-identifier">find</span> :<span class="ruby-identifier">all</span>, :<span class="ruby-identifier">include</span> =<span class="ruby-operator">&gt;</span> {:<span class="ruby-identifier">children</span> =<span class="ruby-operator">&gt;</span> {:<span class="ruby-identifier">parent</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">children</span>}} 
<span class="ruby-comment"># =&gt; SELECT ... FROM mixins LEFT OUTER JOIN mixins childrens_mixins ... </span>
                            <span class="ruby-constant">LEFT</span> <span class="ruby-constant">OUTER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">parents_mixins</span> <span class="ruby-operator">...</span>
</pre>

<p>LEFT OUTER JOIN mixins childrens_mixins_2</p>

<p>Has and Belongs to Many join tables use the same idea, but add a _join
suffix:</p>

<pre class="ruby"><span class="ruby-constant">Post</span>.<span class="ruby-identifier">find</span> :<span class="ruby-identifier">all</span>, :<span class="ruby-identifier">include</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">categories</span>
<span class="ruby-comment"># =&gt; SELECT ... FROM posts LEFT OUTER JOIN categories_posts ... LEFT OUTER JOIN categories ...</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">find</span> :<span class="ruby-identifier">all</span>, :<span class="ruby-identifier">include</span> =<span class="ruby-operator">&gt;</span> {:<span class="ruby-identifier">categories</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">posts</span>}
<span class="ruby-comment"># =&gt; SELECT ... FROM posts LEFT OUTER JOIN categories_posts ... LEFT OUTER JOIN categories ...</span>
                           <span class="ruby-constant">LEFT</span> <span class="ruby-constant">OUTER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">categories_posts</span> <span class="ruby-identifier">posts_categories_join</span> <span class="ruby-constant">LEFT</span> <span class="ruby-constant">OUTER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">posts</span> <span class="ruby-identifier">posts_categories</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">find</span> :<span class="ruby-identifier">all</span>, :<span class="ruby-identifier">include</span> =<span class="ruby-operator">&gt;</span> {:<span class="ruby-identifier">categories</span> =<span class="ruby-operator">&gt;</span> {:<span class="ruby-identifier">posts</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">categories</span>}}
<span class="ruby-comment"># =&gt; SELECT ... FROM posts LEFT OUTER JOIN categories_posts ... LEFT OUTER JOIN categories ...</span>
                           <span class="ruby-constant">LEFT</span> <span class="ruby-constant">OUTER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">categories_posts</span> <span class="ruby-identifier">posts_categories_join</span> <span class="ruby-constant">LEFT</span> <span class="ruby-constant">OUTER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">posts</span> <span class="ruby-identifier">posts_categories</span>
                           <span class="ruby-constant">LEFT</span> <span class="ruby-constant">OUTER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">categories_posts</span> <span class="ruby-identifier">categories_posts_join</span> <span class="ruby-constant">LEFT</span> <span class="ruby-constant">OUTER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">categories</span> <span class="ruby-identifier">categories_posts</span>
</pre>

<p>If you wish to specify your own custom joins using a :joins option, those
table names will take precedence over the eager associations..</p>

<pre class="ruby"><span class="ruby-constant">Post</span>.<span class="ruby-identifier">find</span> :<span class="ruby-identifier">all</span>, :<span class="ruby-identifier">include</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">comments</span>, :<span class="ruby-identifier">joins</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;inner join comments ...&quot;</span>
<span class="ruby-comment"># =&gt; SELECT ... FROM posts LEFT OUTER JOIN comments_posts ON ... INNER JOIN comments ...</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">find</span> :<span class="ruby-identifier">all</span>, :<span class="ruby-identifier">include</span> =<span class="ruby-operator">&gt;</span> [:<span class="ruby-identifier">comments</span>, :<span class="ruby-identifier">special_comments</span>], :<span class="ruby-identifier">joins</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;inner join comments ...&quot;</span>
<span class="ruby-comment"># =&gt; SELECT ... FROM posts LEFT OUTER JOIN comments comments_posts ON ... </span>
                           <span class="ruby-constant">LEFT</span> <span class="ruby-constant">OUTER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">comments</span> <span class="ruby-identifier">special_comments_posts</span> <span class="ruby-operator">...</span>
                           <span class="ruby-constant">INNER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">comments</span> <span class="ruby-operator">...</span>
</pre>

<p>Table aliases are automatically truncated according to the maximum length
of table identifiers according to the specific database.</p>

<h2 id="label-Modules">Modules</h2>

<p>By default, associations will look for objects within the current module
scope. Consider:</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">MyApplication</span>
  <span class="ruby-keyword">module</span> <span class="ruby-constant">Business</span>
    <span class="ruby-keyword">class</span> <span class="ruby-constant">Firm</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
       <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">clients</span>
     <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">class</span> <span class="ruby-constant">Company</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>; <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>When Firm#clients is called, it’ll in turn call
<code>MyApplication::Business::Company.find(firm.id)</code>. If you want to
associate with a class in another module scope this can be done by
specifying the complete class name, such as:</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">MyApplication</span>
  <span class="ruby-keyword">module</span> <span class="ruby-constant">Business</span>
    <span class="ruby-keyword">class</span> <span class="ruby-constant">Firm</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>; <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">module</span> <span class="ruby-constant">Billing</span>
    <span class="ruby-keyword">class</span> <span class="ruby-constant">Account</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
      <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">firm</span>, :<span class="ruby-identifier">class_name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;MyApplication::Business::Firm&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-Type+safety+with+ActiveRecord%3A%3AAssociationTypeMismatch">Type safety with ActiveRecord::AssociationTypeMismatch</h2>

<p>If you attempt to assign an object to an association that doesn’t match the
inferred or specified <code>:class_name</code>, you’ll get a
ActiveRecord::AssociationTypeMismatch.</p>

<h2 id="label-Options">Options</h2>

<p>All of the association macros can be specialized through options which
makes more complex cases than the simple and guessable ones possible.</p>

    </div>
  


  


  
  


  


  
    <!-- Method ref -->
    <div class="sectiontitle">Methods</div>
    <dl class="methods">
      
        <dt>B</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-belongs_to">belongs_to</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>H</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-has_and_belongs_to_many">has_and_belongs_to_many</a>,
              </li>
            
              
              <li>
                <a href="#method-i-has_many">has_many</a>,
              </li>
            
              
              <li>
                <a href="#method-i-has_one">has_one</a>
              </li>
            
          </ul>
        </dd>
      
    </dl>
  

  



  

    

    

    


    


    <!-- Methods -->
        
      <div class="sectiontitle">Instance Public methods</div>
      
        <div class="method">
          <div class="title method-title" id="method-i-belongs_to">
            
              <a name="method-i-belongs_to"></a><b>belongs_to</b>(association_id, options = {})
            
          </div>
          
          
            <div class="description">
              <p>Adds the following methods for retrieval and query for a single associated
object that this object holds an id to. <code>association</code> is
replaced with the symbol passed as the first argument, so  <code>belongs_to
:author</code> would add among others <code>author.nil?</code>.</p>
<ul><li>
<p><code>association(force_reload = false)</code> - returns the associated
object. Nil is returned if none is found.</p>
</li><li>
<p><code>association=(associate)</code> - assigns the associate object,
extracts the primary key, and sets it as the foreign key.</p>
</li><li>
<p><code>association.nil?</code> - returns true if there is no associated
object.</p>
</li><li>
<p><code>build_association(attributes = {})</code> - returns a new object of
the associated type that has been instantiated with <code>attributes</code>
and linked to this object through a foreign key but has not yet been saved.</p>
</li><li>
<p><code>create_association(attributes = {})</code> - returns a new object of
the associated type that has been instantiated with <code>attributes</code>
and linked to this object through a foreign key and that has already been
saved (if it passed the validation).</p>
</li></ul>

<p>Example: <a href="../../A.html">A</a> <a href="../../Post.html">Post</a>
class declares <code>belongs_to :author</code>, which will add:</p>
<ul><li>
<p><code>Post#author</code> (similar to <code>Author.find(author_id)</code>)</p>
</li><li>
<p><code>Post#author=(author)</code> (similar to <code>post.author_id =
author.id</code>)</p>
</li><li>
<p><code>Post#author?</code> (similar to <code>post.author ==
some_author</code>)</p>
</li><li>
<p><code>Post#author.nil?</code></p>
</li><li>
<p><code>Post#build_author</code> (similar to <code>post.author =
Author.new</code>)</p>
</li><li>
<p><code>Post#create_author</code> (similar to <code>post.author = Author.new;
post.author.save; post.author</code>)</p>
</li></ul>

<p>The declaration can also include an options hash to specialize the behavior
of the association.</p>

<p>Options are:</p>
<ul><li>
<p><code>:class_name</code>  - specify the class name of the association. Use
it only if that name can't be inferred from the association name. So
<code>has_one :author</code> will by default be linked to the
<code>Author</code> class, but if the real class name is
<code>Person</code>, you'll have to specify it with this option.</p>
</li><li>
<p><code>:conditions</code>  - specify the conditions that the associated
object must meet in order to be included as a "WHERE" sql fragment, such as
"authorized = 1".</p>
</li><li>
<p><code>:order</code>       - specify the order from which the associated
object will be picked at the top. Specified as an "ORDER BY" sql fragment,
such as "last_name, first_name DESC"</p>
</li><li>
<p><code>:foreign_key</code> - specify the foreign key used for the
association. By default this is guessed to be the name of the associated
class in lower-case and "_id" suffixed. So a <code>Person</code> class that
makes a <a href="ClassMethods.html#method-i-belongs_to">#belongs_to</a>
association to a <code>Boss</code> class will use "boss_id" as the default
foreign_key.</p>
</li><li>
<p><code>:counter_cache</code> - caches the number of belonging objects on the
associate class through use of increment_counter  and decrement_counter.
The counter cache is incremented when an object of this class is created
and decremented when it's destroyed. This requires that a column named
"#{table_name}_count" (such as comments_count for a belonging <a
href="../../Comment.html">Comment</a> class) is used on the associate class
(such as a <a href="../../Post.html">Post</a> class). You can also specify
a custom counter cache column by given that name instead of a true/false
value to this option (e.g., <code>:counter_cache =&gt;
:my_custom_counter</code>.)</p>
</li><li>
<p><code>:include</code>  - specify second-order associations that should be
eager loaded when this object is loaded.</p>
</li><li>
<p><code>:polymorphic</code> - specify this association is a polymorphic
association by passing true.</p>
</li></ul>

<p>Option examples:</p>

<pre class="ruby"><span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">firm</span>, :<span class="ruby-identifier">foreign_key</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;client_of&quot;</span>
<span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">author</span>, :<span class="ruby-identifier">class_name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;Person&quot;</span>, :<span class="ruby-identifier">foreign_key</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;author_id&quot;</span>
<span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">valid_coupon</span>, :<span class="ruby-identifier">class_name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;Coupon&quot;</span>, :<span class="ruby-identifier">foreign_key</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;coupon_id&quot;</span>, 
           :<span class="ruby-identifier">conditions</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'discounts &gt; #{payments_count}'</span>
<span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">attachable</span>, :<span class="ruby-identifier">polymorphic</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>
</pre>
            </div>
          
          
          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-belongs_to_source')" id="l_method-i-belongs_to_source">show</a>
                
              </p>
              <div id="method-i-belongs_to_source" class="dyn-source">
                <pre><span class="ruby-comment"># File rails/activerecord/lib/active_record/associations.rb, line 699</span>
      <span class="ruby-keyword">def</span> <span class="ruby-keyword ruby-title">belongs_to</span>(<span class="ruby-identifier">association_id</span>, <span class="ruby-identifier">options</span> = {})
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-value">:class_name</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">options</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-value">:foreign_key</span>)
          <span class="ruby-operator">::</span><span class="ruby-constant">ActiveSupport</span><span class="ruby-operator">::</span><span class="ruby-constant">Deprecation</span>.<span class="ruby-identifier">warn</span>(
          <span class="ruby-string">&quot;The inferred foreign_key name will change in Rails 2.0 to use the association name instead of its class name when they differ.  When using :class_name in belongs_to, use the :foreign_key option to explicitly set the key name to avoid problems in the transition.&quot;</span>,
          <span class="ruby-identifier">caller</span>)
        <span class="ruby-keyword">end</span>
        
        <span class="ruby-identifier">reflection</span> = <span class="ruby-identifier">create_belongs_to_reflection</span>(<span class="ruby-identifier">association_id</span>, <span class="ruby-identifier">options</span>)
        
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">options</span>[<span class="ruby-value">:polymorphic</span>]
          <span class="ruby-identifier">association_accessor_methods</span>(<span class="ruby-identifier">reflection</span>, <span class="ruby-constant">BelongsToPolymorphicAssociation</span>)

          <span class="ruby-identifier">module_eval</span> <span class="ruby-keyword">do</span>
            <span class="ruby-identifier">before_save</span> <span class="ruby-string">&quot;              association = instance_variable_get(&quot;@#{reflection.name}&quot;)
              if association &amp;&amp; association.target
                if association.new_record?
                  association.save(true)
                end
                
                if association.updated?
                  self[&quot;#{reflection.primary_key_name}&quot;] = association.id
                  self[&quot;#{reflection.options[:foreign_type]}&quot;] = association.class.base_class.name.to_s
                end
              end
&quot;</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">association_accessor_methods</span>(<span class="ruby-identifier">reflection</span>, <span class="ruby-constant">BelongsToAssociation</span>)
          <span class="ruby-identifier">association_constructor_method</span>(<span class="ruby-value">:build</span>,  <span class="ruby-identifier">reflection</span>, <span class="ruby-constant">BelongsToAssociation</span>)
          <span class="ruby-identifier">association_constructor_method</span>(<span class="ruby-value">:create</span>, <span class="ruby-identifier">reflection</span>, <span class="ruby-constant">BelongsToAssociation</span>)

          <span class="ruby-identifier">module_eval</span> <span class="ruby-keyword">do</span>
            <span class="ruby-identifier">before_save</span> <span class="ruby-string">&quot;              association = instance_variable_get(&quot;@#{reflection.name}&quot;)
              if !association.nil? 
                if association.new_record?
                  association.save(true)
                end
                
                if association.updated?
                  self[&quot;#{reflection.primary_key_name}&quot;] = association.id
                end
              end            
&quot;</span>
          <span class="ruby-keyword">end</span>
      
          <span class="ruby-comment"># deprecated api</span>
          <span class="ruby-identifier">deprecated_has_association_method</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>)
          <span class="ruby-identifier">deprecated_association_comparison_method</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">class_name</span>)
        <span class="ruby-keyword">end</span>

        <span class="ruby-comment"># Create the callbacks to update counter cache</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:counter_cache</span>]
          <span class="ruby-identifier">cache_column</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:counter_cache</span>] <span class="ruby-operator">==</span> <span class="ruby-keyword">true</span> <span class="ruby-operator">?</span>
            <span class="ruby-node">&quot;#{self.to_s.underscore.pluralize}_count&quot;</span> <span class="ruby-operator">:</span>
            <span class="ruby-identifier">options</span>[<span class="ruby-value">:counter_cache</span>]

          <span class="ruby-identifier">module_eval</span>(
            <span class="ruby-node">&quot;after_create '#{reflection.name}.class.increment_counter(\&quot;#{cache_column}\&quot;, #{reflection.primary_key_name})&quot;</span> <span class="ruby-operator">+</span>
            <span class="ruby-node">&quot; unless #{reflection.name}.nil?'&quot;</span>
          )

          <span class="ruby-identifier">module_eval</span>(
            <span class="ruby-node">&quot;before_destroy '#{reflection.name}.class.decrement_counter(\&quot;#{cache_column}\&quot;, #{reflection.primary_key_name})&quot;</span> <span class="ruby-operator">+</span>
            <span class="ruby-node">&quot; unless #{reflection.name}.nil?'&quot;</span>
          )          
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-has_and_belongs_to_many">
            
              <a name="method-i-has_and_belongs_to_many"></a><b>has_and_belongs_to_many</b>(association_id, options = {}, &amp;extension)
            
          </div>
          
          
            <div class="description">
              <p>Associates two classes via an intermediate join table.  Unless the join
table is explicitly specified as an option, it is guessed using the lexical
order of the class names. So a join between <a
href="../../Developer.html">Developer</a> and <a
href="../../Project.html">Project</a> will give the default join table name
of “developers_projects” because “D” outranks “P”.  Note that this
precedence is calculated using the <code>&lt;</code> operator for
<code>String</code>.  This means that if the strings are of different
lengths,  and the strings are equal when compared up to the shortest
length, then the longer string is considered of higher lexical precedence
than the shorter one.  For example, one would expect the tables
<code>paper_boxes</code> and <code>papers</code>  to generate a join table
name of <code>papers_paper_boxes</code> because of the length of the name
<code>paper_boxes</code>, but it in fact generates a join table name of
<code>paper_boxes_papers</code>.  Be aware of this caveat, and use the 
custom <code>join_table</code> option if you need to.</p>

<p>Deprecated: Any additional fields added to the join table will be placed as
attributes when pulling records out through <a
href="ClassMethods.html#method-i-has_and_belongs_to_many">#has_and_belongs_to_many</a>
associations. Records returned from join tables with additional attributes
will be marked as ReadOnly (because we can’t save changes to the additional
attrbutes). It’s strongly recommended that you upgrade any associations
with attributes to a real join model (see introduction).</p>

<p>Adds the following methods for retrieval and query. <code>collection</code>
is replaced with the symbol passed as the first argument, so 
<code>has_and_belongs_to_many :categories</code> would add among others
<code>categories.empty?</code>.</p>
<ul><li>
<p><code>collection(force_reload = false)</code> - returns an array of all the
associated objects. An empty array is returned if none is found.</p>
</li><li>
<p><code>collection&lt;&lt;(object, ...)</code> - adds one or more objects to
the collection by creating associations in the join table  (collection.push
and collection.concat are aliases to this method).</p>
</li><li>
<p><code>collection.push_with_attributes(object, join_attributes)</code> -
adds one to the collection by creating an association in the join table
that also holds the attributes from <code>join_attributes</code> (should be
a hash with the column names as keys). This can be used to have additional
attributes on the join, which will be injected into the associated objects
when they are retrieved through the collection.
(collection.concat_with_attributes is an alias to this method). This method
is now deprecated.</p>
</li><li>
<p><code>collection.delete(object, ...)</code> - removes one or more objects
from the collection by removing their associations from the join table.</p>

<p>This does not destroy the objects.</p>
</li><li>
<p><code>collection=objects</code> - replaces the collections content by
deleting and adding objects as appropriate.</p>
</li><li>
<p><code>collection_singular_ids</code> - returns an array of the associated
objects ids</p>
</li><li>
<p><code>collection_singular_ids=ids</code> - replace the collection by the
objects identified by the primary keys in <code>ids</code></p>
</li><li>
<p><code>collection.clear</code> - removes every object from the collection.
This does not destroy the objects.</p>
</li><li>
<p><code>collection.empty?</code> - returns true if there are no associated
objects.</p>
</li><li>
<p><code>collection.size</code> - returns the number of associated objects.</p>
</li><li>
<p><code>collection.find(id)</code> - finds an associated object responding to
the <code>id</code> and that meets the condition that it has to be
associated with this object.</p>
</li><li>
<p><code>collection.build(attributes = {})</code> - returns a new object of
the collection type that has been instantiated with <code>attributes</code>
and linked to this object through the join table but has not yet been
saved.</p>
</li><li>
<p><code>collection.create(attributes = {})</code> - returns a new object of
the collection type that has been instantiated with <code>attributes</code>
and linked to this object through the join table and that has already been
saved (if it passed the validation).</p>
</li></ul>

<p>Example: An <a href="../../Developer.html">Developer</a> class declares
<code>has_and_belongs_to_many :projects</code>, which will add:</p>
<ul><li>
<p><code>Developer#projects</code></p>
</li><li>
<p><code>Developer#projects&lt;&lt;</code></p>
</li><li>
<p><code>Developer#projects.delete</code></p>
</li><li>
<p><code>Developer#projects=</code></p>
</li><li>
<p><code>Developer#project_ids</code></p>
</li><li>
<p><code>Developer#project_ids=</code></p>
</li><li>
<p><code>Developer#projects.clear</code></p>
</li><li>
<p><code>Developer#projects.empty?</code></p>
</li><li>
<p><code>Developer#projects.size</code></p>
</li><li>
<p><code>Developer#projects.find(id)</code></p>
</li><li>
<p><code>Developer#projects.build</code> (similar to
<code>Project.new(&quot;project_id&quot; =&gt; id)</code>)</p>
</li><li>
<p><code>Developer#projects.create</code> (similar to <code>c =
Project.new(&quot;project_id&quot; =&gt; id); c.save; c</code>)</p>
</li></ul>

<p>The declaration may include an options hash to specialize the behavior of
the association.</p>

<p>Options are:</p>
<ul><li>
<p><code>:class_name</code> - specify the class name of the association. Use
it only if that name can't be inferred from the association name. So
<code>has_and_belongs_to_many :projects</code> will by default be linked to
the  <code>Project</code> class, but if the real class name is
<code>SuperProject</code>, you'll have to specify it with this option.</p>
</li><li>
<p><code>:join_table</code> - specify the name of the join table if the
default based on lexical order isn't what you want. WARNING: If you're
overwriting the table name of either class, the table_name method MUST be
declared underneath any <a
href="ClassMethods.html#method-i-has_and_belongs_to_many">#has_and_belongs_to_many</a>
declaration in order to work.</p>
</li><li>
<p><code>:foreign_key</code> - specify the foreign key used for the
association. By default this is guessed to be the name of this class in
lower-case and "_id" suffixed. So a <code>Person</code> class that makes a
<a
href="ClassMethods.html#method-i-has_and_belongs_to_many">#has_and_belongs_to_many</a>
association will use "person_id" as the default foreign_key.</p>
</li><li>
<p><code>:association_foreign_key</code> - specify the association foreign key
used for the association. By default this is guessed to be the name of the
associated class in lower-case and "_id" suffixed. So if the associated
class is <code>Project</code>, the <a
href="ClassMethods.html#method-i-has_and_belongs_to_many">#has_and_belongs_to_many</a>
association will use "project_id" as the default association foreign_key.</p>
</li><li>
<p><code>:conditions</code>  - specify the conditions that the associated
object must meet in order to be included as a "WHERE" sql fragment, such as
"authorized = 1".</p>
</li><li>
<p><code>:order</code> - specify the order in which the associated objects are
returned as a "ORDER BY" sql fragment, such as "last_name, first_name DESC"</p>
</li><li>
<p><code>:uniq</code> - if set to true, duplicate associated objects will be
ignored by accessors and query methods</p>
</li><li>
<p><code>:finder_sql</code> - overwrite the default generated SQL used to
fetch the association with a manual one</p>
</li><li>
<p><code>:delete_sql</code> - overwrite the default generated SQL used to
remove links between the associated  classes with a manual one</p>
</li><li>
<p><code>:insert_sql</code> - overwrite the default generated SQL used to add
links between the associated classes with a manual one</p>
</li><li>
<p><code>:extend</code>  - anonymous module for extending the proxy, see
"Association extensions".</p>
</li><li>
<p><code>:include</code>  - specify second-order associations that should be
eager loaded when the collection is loaded.</p>
</li><li>
<p><code>:group</code>: An attribute name by which the result should be
grouped. Uses the GROUP BY SQL-clause.</p>
</li><li>
<p><code>:limit</code>: An integer determining the limit on the number of rows
that should be returned.</p>
</li><li>
<p><code>:offset</code>: An integer determining the offset from where the rows
should be fetched. So at 5, it would skip the first 4 rows.</p>
</li><li>
<p><code>:select</code>: By default, this is * as in SELECT * FROM, but can be
changed if you for example want to do a join, but not include the joined
columns.</p>
</li></ul>

<p>Option examples:</p>

<pre class="ruby"><span class="ruby-identifier">has_and_belongs_to_many</span> :<span class="ruby-identifier">projects</span>
<span class="ruby-identifier">has_and_belongs_to_many</span> :<span class="ruby-identifier">projects</span>, :<span class="ruby-identifier">include</span> =<span class="ruby-operator">&gt;</span> [ :<span class="ruby-identifier">milestones</span>, :<span class="ruby-identifier">manager</span> ]
<span class="ruby-identifier">has_and_belongs_to_many</span> :<span class="ruby-identifier">nations</span>, :<span class="ruby-identifier">class_name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;Country&quot;</span>
<span class="ruby-identifier">has_and_belongs_to_many</span> :<span class="ruby-identifier">categories</span>, :<span class="ruby-identifier">join_table</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;prods_cats&quot;</span>
<span class="ruby-identifier">has_and_belongs_to_many</span> :<span class="ruby-identifier">active_projects</span>, :<span class="ruby-identifier">join_table</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'developers_projects'</span>, :<span class="ruby-identifier">delete_sql</span> =<span class="ruby-operator">&gt;</span> 
<span class="ruby-string">'DELETE FROM developers_projects WHERE active=1 AND developer_id = #{id} AND project_id = #{record.id}'</span>
</pre>
            </div>
          
          
          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-has_and_belongs_to_many_source')" id="l_method-i-has_and_belongs_to_many_source">show</a>
                
              </p>
              <div id="method-i-has_and_belongs_to_many_source" class="dyn-source">
                <pre><span class="ruby-comment"># File rails/activerecord/lib/active_record/associations.rb, line 862</span>
      <span class="ruby-keyword">def</span> <span class="ruby-keyword ruby-title">has_and_belongs_to_many</span>(<span class="ruby-identifier">association_id</span>, <span class="ruby-identifier">options</span> = {}, &amp;<span class="ruby-identifier">extension</span>)
        <span class="ruby-identifier">reflection</span> = <span class="ruby-identifier">create_has_and_belongs_to_many_reflection</span>(<span class="ruby-identifier">association_id</span>, <span class="ruby-identifier">options</span>, &amp;<span class="ruby-identifier">extension</span>)
        
        <span class="ruby-identifier">add_multiple_associated_save_callbacks</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>)
        <span class="ruby-identifier">collection_accessor_methods</span>(<span class="ruby-identifier">reflection</span>, <span class="ruby-constant">HasAndBelongsToManyAssociation</span>)

        <span class="ruby-comment"># Don't use a before_destroy callback since users' before_destroy</span>
        <span class="ruby-comment"># callbacks will be executed after the association is wiped out.</span>
        <span class="ruby-identifier">old_method</span> = <span class="ruby-node">&quot;destroy_without_habtm_shim_for_#{reflection.name}&quot;</span>
        <span class="ruby-identifier">class_eval</span> <span class="ruby-string">&quot;          alias_method :#{old_method}, :destroy_without_callbacks
          def destroy_without_callbacks
            #{reflection.name}.clear
            #{old_method}
          end
&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">method_defined?</span>(<span class="ruby-identifier">old_method</span>)

        <span class="ruby-identifier">add_association_callbacks</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">options</span>)
        
        <span class="ruby-comment"># deprecated api</span>
        <span class="ruby-identifier">deprecated_collection_count_method</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>)
        <span class="ruby-identifier">deprecated_add_association_relation</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>)
        <span class="ruby-identifier">deprecated_remove_association_relation</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>)
        <span class="ruby-identifier">deprecated_has_collection_method</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>)
      <span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-has_many">
            
              <a name="method-i-has_many"></a><b>has_many</b>(association_id, options = {}, &amp;extension)
            
          </div>
          
          
            <div class="description">
              <p>Adds the following methods for retrieval and query of collections of
associated objects. <code>collection</code> is replaced with the symbol
passed as the first argument, so  <code>has_many :clients</code> would add
among others <code>clients.empty?</code>.</p>
<ul><li>
<p><code>collection(force_reload = false)</code> - returns an array of all the
associated objects. An empty array is returned if none are found.</p>
</li><li>
<p><code>collection&lt;&lt;(object, ...)</code> - adds one or more objects to
the collection by setting their foreign keys to the collection's primary
key.</p>
</li><li>
<p><code>collection.delete(object, ...)</code> - removes one or more objects
from the collection by setting their foreign keys to NULL.</p>

<p>This will also destroy the objects if they’re declared as <a
href="ClassMethods.html#method-i-belongs_to">#belongs_to</a> and dependent
on this model.</p>
</li><li>
<p><code>collection=objects</code> - replaces the collections content by
deleting and adding objects as appropriate.</p>
</li><li>
<p><code>collection_singular_ids</code> - returns an array of the associated
objects ids</p>
</li><li>
<p><code>collection_singular_ids=ids</code> - replace the collection by the
objects identified by the primary keys in <code>ids</code></p>
</li><li>
<p><code>collection.clear</code> - removes every object from the collection.
This destroys the associated objects if they are <code>:dependent</code>,
deletes them directly from the database if they are <code>:dependent =&gt;
:delete_all</code>, and sets their foreign keys to NULL otherwise.</p>
</li><li>
<p><code>collection.empty?</code> - returns true if there are no associated
objects.</p>
</li><li>
<p><code>collection.size</code> - returns the number of associated objects.</p>
</li><li>
<p><code>collection.find</code> - finds an associated object according to the
same rules as <a
href="../Base.html#method-c-find">ActiveRecord::Base.find</a>.</p>
</li><li>
<p><code>collection.build(attributes = {})</code> - returns a new object of
the collection type that has been instantiated with <code>attributes</code>
and linked to this object through a foreign key but has not yet been saved.
<strong>Note:</strong> This only works if an  associated object already
exists, not if it's nil!</p>
</li><li>
<p><code>collection.create(attributes = {})</code> - returns a new object of
the collection type that has been instantiated with <code>attributes</code>
and linked to this object through a foreign key and that has already been
saved (if it passed the validation). <strong>Note:</strong> This only works
if an associated object already exists, not if it's nil!</p>
</li></ul>

<p>Example: <a href="../../A.html">A</a> <a href="../../Firm.html">Firm</a>
class declares <code>has_many :clients</code>, which will add:</p>
<ul><li>
<p><code>Firm#clients</code> (similar to <code>Clients.find :all, :conditions
=&gt; &quot;firm_id = #{id}&quot;</code>)</p>
</li><li>
<p><code>Firm#clients&lt;&lt;</code></p>
</li><li>
<p><code>Firm#clients.delete</code></p>
</li><li>
<p><code>Firm#clients=</code></p>
</li><li>
<p><code>Firm#client_ids</code></p>
</li><li>
<p><code>Firm#client_ids=</code></p>
</li><li>
<p><code>Firm#clients.clear</code></p>
</li><li>
<p><code>Firm#clients.empty?</code> (similar to <code>firm.clients.size ==
0</code>)</p>
</li><li>
<p><code>Firm#clients.size</code> (similar to <code>Client.count &quot;firm_id
= #{id}&quot;</code>)</p>
</li><li>
<p><code>Firm#clients.find</code> (similar to <code>Client.find(id,
:conditions =&gt; &quot;firm_id = #{id}&quot;)</code>)</p>
</li><li>
<p><code>Firm#clients.build</code> (similar to
<code>Client.new(&quot;firm_id&quot; =&gt; id)</code>)</p>
</li><li>
<p><code>Firm#clients.create</code> (similar to <code>c =
Client.new(&quot;firm_id&quot; =&gt; id); c.save; c</code>)</p>
</li></ul>

<p>The declaration can also include an options hash to specialize the behavior
of the association.</p>

<p>Options are:</p>
<ul><li>
<p><code>:class_name</code>  - specify the class name of the association. Use
it only if that name can't be inferred from the association name. So
<code>has_many :products</code> will by default be linked to the
<code>Product</code> class, but if the real class name is
<code>SpecialProduct</code>, you'll have to specify it with this option.</p>
</li><li>
<p><code>:conditions</code>  - specify the conditions that the associated
objects must meet in order to be included as a "WHERE" sql fragment, such
as "price &gt; 5 AND name LIKE 'B%'".</p>
</li><li>
<p><code>:order</code>       - specify the order in which the associated
objects are returned as a "ORDER BY" sql fragment, such as "last_name,
first_name DESC"</p>
</li><li>
<p><code>:group</code>       - specify the attribute by which the associated
objects are returned as a "GROUP BY" sql fragment, such as "category"</p>
</li><li>
<p><code>:foreign_key</code> - specify the foreign key used for the
association. By default this is guessed to be the name of this class in
lower-case and "_id" suffixed. So a <code>Person</code> class that makes a
<a href="ClassMethods.html#method-i-has_many">#has_many</a> association
will use "person_id" as the default foreign_key.</p>
</li><li>
<p><code>:dependent</code>   - if set to :destroy all the associated objects
are destroyed alongside this object by calling their destroy method.  If
set to :delete_all all associated objects are deleted
<strong>without</strong> calling their destroy method.  If set to :nullify
all associated objects' foreign keys are set to NULL
<strong>without</strong> calling their save callbacks. NOTE: :dependent
=&gt; true is deprecated and has been replaced with :dependent =&gt;
:destroy.  May not be set if :exclusively_dependent is also set.</p>
</li><li>
<p><code>:exclusively_dependent</code>   - Deprecated; equivalent to
:dependent =&gt; :delete_all. If set to true all the associated object are
deleted in one SQL statement without having their before_destroy callback
run. This should only be used on associations that depend solely on this
class and don't need to do any clean-up in before_destroy. The upside is
that it's much faster, especially if there's a counter_cache involved. May
not be set if :dependent is also set.</p>
</li><li>
<p><code>:finder_sql</code>  - specify a complete SQL statement to fetch the
association. This is a good way to go for complex associations that depend
on multiple tables. Note: When this option is used,
<code>find_in_collection</code> is <em>not</em> added.</p>
</li><li>
<p><code>:counter_sql</code>  - specify a complete SQL statement to fetch the
size of the association. If <code>:finder_sql</code> is specified but
<code>:counter_sql</code>, <code>:counter_sql</code> will be generated by
replacing SELECT ... FROM with SELECT COUNT(*) FROM.</p>
</li><li>
<p><code>:extend</code>  - specify a named module for extending the proxy, see
"Association extensions".</p>
</li><li>
<p><code>:include</code>  - specify second-order associations that should be
eager loaded when the collection is loaded.</p>
</li><li>
<p><code>:group</code>: An attribute name by which the result should be
grouped. Uses the GROUP BY SQL-clause.</p>
</li><li>
<p><code>:limit</code>: An integer determining the limit on the number of rows
that should be returned.</p>
</li><li>
<p><code>:offset</code>: An integer determining the offset from where the rows
should be fetched. So at 5, it would skip the first 4 rows.</p>
</li><li>
<p><code>:select</code>: By default, this is * as in SELECT * FROM, but can be
changed if you for example want to do a join, but not include the joined
columns.</p>
</li><li>
<p><code>:as</code>: Specifies a polymorphic interface (See <a
href="ClassMethods.html#method-i-belongs_to">belongs_to</a>).</p>
</li><li>
<p><code>:through</code>: Specifies a Join Model to perform the query through.
Options for <code>:class_name</code> and <code>:foreign_key</code>  are
ignored, as the association uses the source reflection.  You can only use a
<code>:through</code> query through a <code>belongs_to</code> or
<code>has_many</code> association.</p>
</li><li>
<p><code>:source</code>: Specifies the source association name used by
<code>has_many :through</code> queries.  Only use it if the name cannot be 
inferred from the association.  <code>has_many :subscribers, :through =&gt;
:subscriptions</code> will look for either <code>:subscribers</code> or
<code>:subscriber</code> on <code>Subscription</code>, unless a
<code>:source</code> is given.</p>
</li><li>
<p><code>:source_type</code>: Specifies type of the source association used by
<code>has_many :through</code> queries where the source association is a
polymorphic belongs_to.</p>
</li><li>
<p><code>:uniq</code> - if set to true, duplicates will be omitted from the
collection. Useful in conjunction with :through.</p>
</li></ul>

<p>Option examples:</p>

<pre class="ruby"><span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">comments</span>, :<span class="ruby-identifier">order</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;posted_on&quot;</span>
<span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">comments</span>, :<span class="ruby-identifier">include</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">author</span>
<span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">people</span>, :<span class="ruby-identifier">class_name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;Person&quot;</span>, :<span class="ruby-identifier">conditions</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;deleted = 0&quot;</span>, :<span class="ruby-identifier">order</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;name&quot;</span>
<span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">tracks</span>, :<span class="ruby-identifier">order</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;position&quot;</span>, :<span class="ruby-identifier">dependent</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">destroy</span>
<span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">comments</span>, :<span class="ruby-identifier">dependent</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">nullify</span>
<span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">tags</span>, :<span class="ruby-identifier">as</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">taggable</span>
<span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">subscribers</span>, :<span class="ruby-identifier">through</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">subscriptions</span>, :<span class="ruby-identifier">source</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">user</span>
<span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">subscribers</span>, :<span class="ruby-identifier">class_name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;Person&quot;</span>, :<span class="ruby-identifier">finder_sql</span> =<span class="ruby-operator">&gt;</span>
    <span class="ruby-string">'SELECT DISTINCT people.* '</span> <span class="ruby-operator">+</span>
    <span class="ruby-string">'FROM people p, post_subscriptions ps '</span> <span class="ruby-operator">+</span>
    <span class="ruby-string">'WHERE ps.post_id = #{id} AND ps.person_id = p.id '</span> <span class="ruby-operator">+</span>
    <span class="ruby-string">'ORDER BY p.first_name'</span>
</pre>
            </div>
          
          
          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-has_many_source')" id="l_method-i-has_many_source">show</a>
                
              </p>
              <div id="method-i-has_many_source" class="dyn-source">
                <pre><span class="ruby-comment"># File rails/activerecord/lib/active_record/associations.rb, line 569</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword ruby-title">has_many</span>(<span class="ruby-identifier">association_id</span>, <span class="ruby-identifier">options</span> = {}, &amp;<span class="ruby-identifier">extension</span>)
  <span class="ruby-identifier">reflection</span> = <span class="ruby-identifier">create_has_many_reflection</span>(<span class="ruby-identifier">association_id</span>, <span class="ruby-identifier">options</span>, &amp;<span class="ruby-identifier">extension</span>)

  <span class="ruby-identifier">configure_dependency_for_has_many</span>(<span class="ruby-identifier">reflection</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:through</span>]
    <span class="ruby-identifier">collection_reader_method</span>(<span class="ruby-identifier">reflection</span>, <span class="ruby-constant">HasManyThroughAssociation</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">add_multiple_associated_save_callbacks</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>)
    <span class="ruby-identifier">add_association_callbacks</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">options</span>)
    <span class="ruby-identifier">collection_accessor_methods</span>(<span class="ruby-identifier">reflection</span>, <span class="ruby-constant">HasManyAssociation</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">add_deprecated_api_for_has_many</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>)
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-has_one">
            
              <a name="method-i-has_one"></a><b>has_one</b>(association_id, options = {})
            
          </div>
          
          
            <div class="description">
              <p>Adds the following methods for retrieval and query of a single associated
object. <code>association</code> is replaced with the symbol passed as the
first argument, so  <code>has_one :manager</code> would add among others
<code>manager.nil?</code>.</p>
<ul><li>
<p><code>association(force_reload = false)</code> - returns the associated
object. Nil is returned if none is found.</p>
</li><li>
<p><code>association=(associate)</code> - assigns the associate object,
extracts the primary key, sets it as the foreign key,  and saves the
associate object.</p>
</li><li>
<p><code>association.nil?</code> - returns true if there is no associated
object.</p>
</li><li>
<p><code>build_association(attributes = {})</code> - returns a new object of
the associated type that has been instantiated with <code>attributes</code>
and linked to this object through a foreign key but has not yet been saved.
Note: This ONLY works if an association already exists. It will NOT work if
the association is nil.</p>
</li><li>
<p><code>create_association(attributes = {})</code> - returns a new object of
the associated type that has been instantiated with <code>attributes</code>
and linked to this object through a foreign key and that has already been
saved (if it passed the validation).</p>
</li></ul>

<p>Example: An <a href="../../Account.html">Account</a> class declares
<code>has_one :beneficiary</code>, which will add:</p>
<ul><li>
<p><code>Account#beneficiary</code> (similar to <code>Beneficiary.find(:first,
:conditions =&gt; &quot;account_id = #{id}&quot;)</code>)</p>
</li><li>
<p><code>Account#beneficiary=(beneficiary)</code> (similar to
<code>beneficiary.account_id = account.id; beneficiary.save</code>)</p>
</li><li>
<p><code>Account#beneficiary.nil?</code></p>
</li><li>
<p><code>Account#build_beneficiary</code> (similar to
<code>Beneficiary.new(&quot;account_id&quot; =&gt; id)</code>)</p>
</li><li>
<p><code>Account#create_beneficiary</code> (similar to <code>b =
Beneficiary.new(&quot;account_id&quot; =&gt; id); b.save; b</code>)</p>
</li></ul>

<p>The declaration can also include an options hash to specialize the behavior
of the association.</p>

<p>Options are:</p>
<ul><li>
<p><code>:class_name</code>  - specify the class name of the association. Use
it only if that name can't be inferred from the association name. So
<code>has_one :manager</code> will by default be linked to the
<code>Manager</code> class, but if the real class name is
<code>Person</code>, you'll have to specify it with this option.</p>
</li><li>
<p><code>:conditions</code>  - specify the conditions that the associated
object must meet in order to be included as a "WHERE" sql fragment, such as
"rank = 5".</p>
</li><li>
<p><code>:order</code>       - specify the order from which the associated
object will be picked at the top. Specified as</p>

<pre>an &quot;ORDER BY&quot; sql fragment, such as &quot;last_name, first_name DESC&quot;</pre>
</li><li>
<p><code>:dependent</code>   - if set to :destroy (or true) the associated
object is destroyed when this object is. If set to :delete the associated
object is deleted <strong>without</strong> calling its destroy method. If
set to :nullify the associated object's foreign key is set to NULL. Also,
association is assigned.</p>
</li><li>
<p><code>:foreign_key</code> - specify the foreign key used for the
association. By default this is guessed to be the name of this class in
lower-case and "_id" suffixed. So a <code>Person</code> class that makes a
<a href="ClassMethods.html#method-i-has_one">#has_one</a> association will
use "person_id" as the default foreign_key.</p>
</li><li>
<p><code>:include</code>  - specify second-order associations that should be
eager loaded when this object is loaded.</p>
</li><li>
<p><code>:as</code>: Specifies a polymorphic interface (See <a
href="ClassMethods.html#method-i-belongs_to">belongs_to</a>).</p>
</li></ul>

<p>Option examples:</p>

<pre class="ruby"><span class="ruby-identifier">has_one</span> :<span class="ruby-identifier">credit_card</span>, :<span class="ruby-identifier">dependent</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">destroy</span>  <span class="ruby-comment"># destroys the associated credit card</span>
<span class="ruby-identifier">has_one</span> :<span class="ruby-identifier">credit_card</span>, :<span class="ruby-identifier">dependent</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">nullify</span>  <span class="ruby-comment"># updates the associated records foriegn key value to null rather than destroying it</span>
<span class="ruby-identifier">has_one</span> :<span class="ruby-identifier">last_comment</span>, :<span class="ruby-identifier">class_name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;Comment&quot;</span>, :<span class="ruby-identifier">order</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;posted_on&quot;</span>
<span class="ruby-identifier">has_one</span> :<span class="ruby-identifier">project_manager</span>, :<span class="ruby-identifier">class_name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;Person&quot;</span>, :<span class="ruby-identifier">conditions</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;role = 'project_manager'&quot;</span>
<span class="ruby-identifier">has_one</span> :<span class="ruby-identifier">attachment</span>, :<span class="ruby-identifier">as</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">attachable</span>
</pre>
            </div>
          
          
          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-has_one_source')" id="l_method-i-has_one_source">show</a>
                
              </p>
              <div id="method-i-has_one_source" class="dyn-source">
                <pre><span class="ruby-comment"># File rails/activerecord/lib/active_record/associations.rb, line 630</span>
      <span class="ruby-keyword">def</span> <span class="ruby-keyword ruby-title">has_one</span>(<span class="ruby-identifier">association_id</span>, <span class="ruby-identifier">options</span> = {})
        <span class="ruby-identifier">reflection</span> = <span class="ruby-identifier">create_has_one_reflection</span>(<span class="ruby-identifier">association_id</span>, <span class="ruby-identifier">options</span>)

        <span class="ruby-identifier">module_eval</span> <span class="ruby-keyword">do</span>
          <span class="ruby-identifier">after_save</span> <span class="ruby-string">&quot;            association = instance_variable_get(&quot;@#{reflection.name}&quot;)
            if !association.nil? &amp;&amp; (new_record? || association.new_record? || association[&quot;#{reflection.primary_key_name}&quot;] != id)
              association[&quot;#{reflection.primary_key_name}&quot;] = id
              association.save(true)
            end
&quot;</span>
        <span class="ruby-keyword">end</span>
      
        <span class="ruby-identifier">association_accessor_methods</span>(<span class="ruby-identifier">reflection</span>, <span class="ruby-constant">HasOneAssociation</span>)
        <span class="ruby-identifier">association_constructor_method</span>(<span class="ruby-value">:build</span>,  <span class="ruby-identifier">reflection</span>, <span class="ruby-constant">HasOneAssociation</span>)
        <span class="ruby-identifier">association_constructor_method</span>(<span class="ruby-value">:create</span>, <span class="ruby-identifier">reflection</span>, <span class="ruby-constant">HasOneAssociation</span>)
        
        <span class="ruby-identifier">configure_dependency_for_has_one</span>(<span class="ruby-identifier">reflection</span>)

        <span class="ruby-comment"># deprecated api</span>
        <span class="ruby-identifier">deprecated_has_association_method</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>)
        <span class="ruby-identifier">deprecated_association_comparison_method</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">class_name</span>)
      <span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
                    </div>
    </div>
  </body>
</html>    